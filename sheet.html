<script id="gear-cards-module">
(function GearCardsModule(){
  'use strict';

  // ---------- Panel & list ----------
  const panel = document.getElementById('gearPanelInner')
             || document.querySelector('#panel-gear #gearPanelInner');
  if(!panel){ console.warn('[GearCards] #gearPanelInner not found.'); return; }

  let list = panel.querySelector('.gear-list');
  if(!list){
    list = document.createElement('section');
    list.className = 'gear-list';
    panel.appendChild(list);
  }

  // ---------- Templates (removed Traits/Notes everywhere) ----------
  const TEMPLATES = {
    weapon_melee: [
      {k:'damage',  t:'text',     label:'Damage'},
      {k:'reach',   t:'text',     label:'Reach/Grip'}
    ],
    weapon_ranged: [
      {k:'damage',  t:'text',     label:'Damage'},
      {k:'range',   t:'text',     label:'Range Bands'},
      {k:'ammo',    t:'text',     label:'Ammo/Reload'}
    ],
    armour: [
      {k:'coverage', t:'text',     label:'Coverage'},
      {k:'armor',    t:'number',   label:'Armour Value'},
      {k:'penalty',  t:'text',     label:'Penalties'}
    ],
    chemical: [
      {k:'dose',       t:'text',     label:'Dose'},
      {k:'duration',   t:'text',     label:'Duration'},
      {k:'effects',    t:'textarea', label:'Effects (+/− dice)'},
      {k:'withdrawal', t:'textarea', label:'Withdrawal/Crash'},
      {k:'addiction',  t:'text',     label:'Addiction Rating'},
      {k:'price',      t:'text',     label:'Price'}
    ],
    gear: [
      /* plain gear now only uses W/S + Gear Bonus + Description */
    ],
  };

  function resolveTemplate(baseType, tags){
    const t = (tags||[]).map(s=>String(s).toLowerCase());
    if (baseType==='weapon'){
      if (t.includes('ranged')||t.includes('firearm')) return 'weapon_ranged';
      return 'weapon_melee';
    }
    if (baseType==='armor' || baseType==='armour') return 'armour';
    if (baseType==='narcotic') return 'chemical';
    return baseType || 'gear';
  }

  const uid = ()=> 'gc_'+Math.random().toString(36).slice(2,9);

  // ---------- Public API ----------
  window.spawnBlankGearCard = function(kind){
    const type = (kind === 'armor') ? 'armour'
               : (kind === 'narcotic') ? 'chemical'
               : (kind||'gear');
    const data = { id: uid(), name:'', description:'', diceMod:0, weight:0, stow:0 };
    const el = createCardEl(type, data);
    list.appendChild(el);
    return el;
  };

  window.spawnGearCardFromLibrary = function(item){
    const type = resolveTemplate(item.type || 'gear', item.tags);
    const el = createCardEl(type, item || {});
    list.appendChild(el);
    return el;
  };

  window.exportCharacterGear = function(){
    const out = [];
    list.querySelectorAll('.gear-card').forEach(card=>{
      const item = {
        id: card.dataset.cardId || null,
        type: card.dataset.cardType || 'gear',
        _locked: card.classList.contains('is-locked'),
        _min: card.classList.contains('min'),
        name: card.querySelector('.card-title')?.value || '',
        description: card.querySelector('.description')?.value || '',
        diceMod: card.querySelector('.gb-input-header')?.value || 0,
        weight:  card.querySelector('input[name="weight"]')?.value ?? 0,
        stow:    card.querySelector('input[name="stow"]')?.value ?? 0
      };
      // include any template-specific values (no Traits fields anymore)
      card.querySelectorAll('.fields-rows input[name]:not([name="weight"]):not([name="stow"]), .fields-rows textarea[name], .fields-rows select[name]')
        .forEach(el=>{
          const k = el.name; if (!k) return;
          item[k] = (el.type === 'checkbox') ? !!el.checked : el.value;
        });
      out.push(item);
    });
    return out;
  };

  window.importCharacterGear = function(items){
    list.innerHTML = '';
    if (!Array.isArray(items)) return;
    items.forEach(data=>{
      const el = createCardEl(data.type || 'gear', data);
      if (data._min) el.classList.add('min');
      if (data._locked) el.classList.add('is-locked');
      list.appendChild(el);
    });
  };

  window.clearGearCards = function(){ list.innerHTML = ''; };

  // ---------- Drag & drop re-order ----------
  if (!list.dataset.ddInit){
    list.dataset.ddInit = '1';
    list.addEventListener('dragover', (e)=>{
      e.preventDefault();
      const after = getCardAfterY(list, e.clientY);
      const dragging = list.querySelector('.gear-card.dragging');
      if (!dragging) return;
      if (after == null) list.appendChild(dragging);
      else list.insertBefore(dragging, after);
      clearDropTargets();
      (after || dragging)?.classList.add('drop-target');
    });
    list.addEventListener('drop', ()=> clearDropTargets());
  }
  function clearDropTargets(){ list.querySelectorAll('.drop-target').forEach(n=>n.classList.remove('drop-target')); }
  function getCardAfterY(container, y){
    const cards = [...container.querySelectorAll('.gear-card:not(.dragging)')];
    return cards.reduce((closest, child)=>{
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height/2;
      if (offset < 0 && offset > closest.offset) return {offset, element:child};
      return closest;
    }, {offset: Number.NEGATIVE_INFINITY, element: null}).element;
  }

  // ---------- Card builder ----------
  function createCardEl(type, data){
    const id = data.id || uid();
    const templateKey = resolveTemplate(type, data.tags);

    const card = document.createElement('article');
    card.className = 'gear-card';
    card.dataset.cardId = id;
    card.dataset.cardType = type;

    // Header
    const header = document.createElement('div');
    header.className = 'card-header';

    const dragHandle = btn('drag-handle','↕','Drag to reorder');
    const title      = inp('text','card-title', data.name || data.title || '', 'Item Name');

    const minBtn  = btn('min-btn','–','Minimise / expand');
    const lockBtn = btn('lock-btn','','Lock / Unlock');
    const setLockIcon = (locked)=> lockBtn.style.backgroundImage = `url('img/${locked ? 'lock.png' : 'lock_open.png'}')`;
    setLockIcon(!!data._locked);

    // Gear Bonus (stacked label + tiny enc-sized number + dice icon)
    const gbWrap  = div('gb-wrap');
    const gbLabel = document.createElement('div'); gbLabel.className='gb-label';
    gbLabel.append(span(null,'gear'), span(null,'bonus'));

    const gbHeader = document.createElement('input');
    gbHeader.type='number'; gbHeader.name='diceMod';
    gbHeader.value = (data.diceMod ?? data.bonus ?? 0);
    gbHeader.className = 'enc-input gb-input gb-input-header'; // exact encumbrance size

    const gbRoll = document.createElement('img');
    gbRoll.src = 'img/roll_icon.png'; gbRoll.alt='Roll';
    gbRoll.className='gb-roll';
    gbRoll.title='Roll gear bonus (add to dice pool)';
    gbRoll.addEventListener('click', ()=>{
      const v = parseInt(gbHeader.value,10) || 0;
      if (v && typeof window.changePool === 'function') window.changePool(+v);
    });

    gbWrap.append(gbLabel, gbHeader, gbRoll);
    header.append(dragHandle, title, minBtn, lockBtn, gbWrap);

    // Body
    const body = div('card-body');
    const rows = div('fields-rows');

    // Template rows (no Traits)
    (TEMPLATES[templateKey] || []).forEach(spec=>{
      const row = div('field-row');
      const label = document.createElement('label'); label.textContent = spec.label;
      let control;
      if (spec.t === 'textarea'){ control = document.createElement('textarea'); control.rows = 2; }
      else { control = document.createElement('input'); control.type = spec.t; }
      control.name = spec.k; control.value = data[spec.k] ?? '';
      row.append(label, control); rows.appendChild(row);
    });

    // W / S row — BOTH inputs use Encumbrance size (so they are small)
    const wsRow = div('field-row ws-row');
    const wLabel = document.createElement('label'); wLabel.textContent = 'W';
    const wNum   = document.createElement('input'); wNum.type='number'; wNum.name='weight';
    wNum.value = data.weight ?? 0; wNum.className = 'enc-input';
    const slash  = document.createElement('span');  slash.className='slash'; slash.textContent = '/';
    const sLabel = document.createElement('label'); sLabel.textContent = 'S';
    const sNum   = document.createElement('input'); sNum.type='number'; sNum.name='stow';
    sNum.value = data.stow ?? 0; sNum.className = 'enc-input';
    wsRow.append(wLabel, wNum, slash, sLabel, sNum);
    rows.appendChild(wsRow);

    // Gear Bonus row (editable, stays in sync with header)
    const gbRow = div('field-row gb-row');
    const gbBodyLabel = document.createElement('label'); gbBodyLabel.textContent = 'Gear Bonus';
    const gbBody = document.createElement('input'); gbBody.type='number'; gbBody.name='diceMod';
    gbBody.value = (data.diceMod ?? 0); gbBody.className='enc-input gb-input gb-input-body';
    gbRow.append(gbBodyLabel, gbBody);
    rows.appendChild(gbRow);

    // Description at the base
    const desc = document.createElement('textarea');
    desc.className = 'description';
    desc.placeholder = 'Description…';
    desc.value = data.description || '';

    // Footer (Remove only)
    const footer = div('card-footer');
    const btnRemove = document.createElement('button');
    btnRemove.type='button'; btnRemove.textContent='Remove'; btnRemove.title='Remove this item';
    btnRemove.addEventListener('click', ()=> card.remove());
    footer.append(btnRemove);

    // Assemble
    body.append(rows, desc);
    card.append(header, body, footer);

    // Behaviour
    // Sync header/body Gear Bonus both ways
    function syncFromHeader(){
      const v = gbHeader.value; gbBody.value = v; data.diceMod = v;
    }
    function syncFromBody(){
      const v = gbBody.value; gbHeader.value = v; data.diceMod = v;
    }
    gbHeader.addEventListener('input', syncFromHeader);
    gbBody.addEventListener('input', syncFromBody);

    // Minimise
    minBtn.addEventListener('click', ()=>{
      card.classList.toggle('min');
      if (!card.classList.contains('min')){
        requestAnimationFrame(()=>{
          desc.style.height = 'auto';
          desc.style.height = (desc.scrollHeight + 2) + 'px';
        });
      }
    });

    // Minimise by clicking empty header area
    header.addEventListener('click', (e)=>{
      const isControl = e.target === title || e.target === gbHeader || e.target === gbRoll
                     || e.target === dragHandle || e.target === minBtn
                     || e.target === lockBtn   || gbWrap.contains(e.target);
      if (isControl) return;
      minBtn.click();
    });

    // Lock
    lockBtn.addEventListener('click', ()=>{
      data._locked = !data._locked;
      applyLockState();
    });

    function applyLockState(){
      const locked = !!data._locked;
      setLockIcon(locked);
      card.classList.toggle('is-locked', locked);
      const controls = card.querySelectorAll('input, textarea, select, button');
      controls.forEach(el=>{
        const keep = (el===dragHandle || el===minBtn || el===lockBtn || el===btnRemove || el===gbRoll);
        if (keep) return;
        el.disabled = locked;
      });
      btnRemove.disabled = locked;
      gbRoll.style.pointerEvents = locked ? 'none' : 'auto';
      gbRoll.style.opacity = locked ? .6 : 1;
    }
    applyLockState();

    title.addEventListener('input', ()=>{ data.name = title.value; });

    // Handle-only drag
    let allowDrag = false;
    dragHandle.addEventListener('mousedown', ()=>{ allowDrag = true; card.setAttribute('draggable','true'); });
    window.addEventListener('mouseup', ()=>{ allowDrag = false; card.removeAttribute('draggable'); });
    card.addEventListener('dragstart', (e)=>{
      if (!allowDrag) { e.preventDefault(); return; }
      card.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      try { e.dataTransfer.setData('text/plain', id); } catch {}
    });
    card.addEventListener('dragend', ()=>{
      card.classList.remove('dragging');
      clearDropTargets();
    });

    return card;
  }

  // ---- helpers ----
  function div(cls){ const n=document.createElement('div'); n.className=cls; return n; }
  function span(cls,txt){ const n=document.createElement('span'); if(cls) n.className=cls; n.textContent=txt; return n; }
  function inp(type,cls,val,ph){ const n=document.createElement('input'); n.type=type; if(cls) n.className=cls; if(val!=null) n.value=val; if(ph) n.placeholder=ph; return n; }
  function btn(cls,txt,title){ const n=document.createElement('button'); if(cls) n.className=cls; n.type='button'; if(txt!=null) n.textContent=txt; if(title) n.title=title; return n; }

})();
</script>
